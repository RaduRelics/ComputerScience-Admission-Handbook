# Constants, Literals & Macros

Constants refer to fixed values that the program may not alter during its execution. These fixed values are also called literals.

Constants can be of any of the basic data types like an integer constant, a floating constant, a character constant, or a string literal. There are enumeration constants as well.

Constants are treated just like regular variables except that their values cannot be modified after their definition.

```C
const int myNum = 15;  // myNum will always be 15
myNum = 10;  // error: assignment of read-only variable 'myNum' 
```

You should always declare the variable as constant when you have values that are unlikely to change:

```C
const int minutesPerHour = 60;
const float PI = 3.14; 
```

## Integer Literals

An integer literal can be a decimal, octal, or hexadecimal constant. A prefix specifies the base or radix: 0x or 0X for hexadecimal, 0 for octal, and nothing for decimal.

An integer literal can also have a suffix that is a combination of U and L, for unsigned and long, respectively. The suffix can be uppercase or lowercase and can be in any order.

Here are some examples of integer literals:
```C
212         /* Legal */
215u        /* Legal */
0xFeeL      /* Legal */
078         /* Illegal: 8 is not an octal digit */
032UU       /* Illegal: cannot repeat a suffix */
```

## Floating-point Literals

A floating-point literal has an integer part, a decimal point, a fractional part, and an exponent part. You can represent floating point literals either in decimal form or exponential form.

While representing decimal form, you must include the decimal point, the exponent, or both; and while representing exponential form, you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E.

Here are some examples of floating-point literals:

```C
3.14159       /* Legal */
314159E-5L    /* Legal */
510E          /* Illegal: incomplete exponent */
210f          /* Illegal: no decimal or exponent */
.e55          /* Illegal: missing integer or fraction */
```

## Character Constants

Character literals are enclosed in single quotes, e.g., 'x' can be stored in a simple variable of **char** type.

A character literal can be a plain character (e.g., 'x'), an escape sequence (e.g., '\t'), or a universal character (e.g., '\u02C0').

There are certain characters in C that represent special meaning when preceded by a backslash for example, newline (\n) or tab (\t).

* Here, you have a list of such escape sequence codes:

| Escape sequence |	Description | Representation|
| :--- | --- | --- |
| | **Simple escape sequences**  | |
 :---: | :----------- | --- |
|\'| single quote |	byte 0x27 in | ASCII encoding |
|\" |	double quote |	byte 0x22 in ASCII encoding |
|\? |	question mark |	byte 0x3f in ASCII encoding |
|\\ |	backslash |	byte 0x5c in ASCII encoding |
|\a |	audible bell| 	byte 0x07 in ASCII encoding |
|\b |	backspace |	byte 0x08 in ASCII encoding |
|\f |	form feed - new page |	byte 0x0c in ASCII encoding |
|**\n** |	**line feed - new line** |	byte 0x0a in ASCII encoding |
|\r |	carriage return |	byte 0x0d in ASCII encoding |
|\t |	horizontal tab |	byte 0x09 in ASCII encoding |
|\v |	vertical tab |	byte 0x0b in ASCII encoding |
| | **Numeric escape sequences** | |
|\nnn |	arbitrary octal value byte nnn |
|\xnn |	arbitrary hexadecimal value byte nn |
| |**Conditional escape sequences** | |
|\c | Implementation-defined | Implementation-defined |
| | **Universal character names** | |
|\unnnn | arbitrary Unicode value; may result in several code units | code point U+nnnn |
|\Unnnnnnnn | arbitrary Unicode value; may result in several code units | code point U+nnnnnnnn |

An example showcasing the new line escape sequence:

```C++
#include <iostream>
using namespace std;

int main() {
   cout<<"Hello World\n";
   return 0;
}
```

# String literals

String literals or constants are enclosed in double quotes "". A string contains characters that are similar to character literals: plain characters, escape sequences, and universal characters.

You can break a long line into multiple lines using string literals and separating them using white spaces.

Here are some examples of string literals. All the three forms are identical strings.

```C
"hello, dear"

"hello, \

dear"

"hello, " "d" "ear"
```

# Defining Constants

There are two simple ways in C to define constants −

* Using **#define** preprocessor.
* Using **const** keyword.

### The #define Preprocessor

Given below is the form to use #define preprocessor to define a constant:

```C++
#define identifier value
```

The following example explains it in detail

```C++
#include <iostream>

#define LENGTH 10   
#define WIDTH  5
#define NEWLINE '\n'

int main() {
   int area;  
  
   area = LENGTH * WIDTH;
   std::cout<<"value of area : "<< area;
   std::cout<<NEWLINE;
   return 0;
}
```

### The const Keyword

You can use const prefix to declare constants with a specific type as follows:

```C++
const type variable = value;
```

```C++
#include <iostream>

int main() {
   const int  LENGTH = 10;
   const int  WIDTH = 5;
   const char NEWLINE = '\n';
   int area;  
   
   area = LENGTH * WIDTH;
   std::cout<<"value of area : "<< area;
   std::cout<< NEWLINE;

   return 0;
}
```

***Note that it is a good programming practice to define constants in CAPITALS.***

# Preprocessors

As the name suggests Preprocessors are programs that process our source code before compilation. There are a number of steps involved between writing a program and executing a program in C / C++. Let us have a look at these steps before we actually start learning about Preprocessors.

![](/img/Preprocessor-In-C.png)

You can see the intermediate steps in the above diagram. The source code written by programmers is stored in the file program.c. This file is then processed by preprocessors and an expanded source code file is generated named program. This expanded file is compiled by the compiler and an object code file is generated named program .obj. Finally, the linker links this object code file to the object code of the library functions to generate the executable file program.exe. 

Preprocessor programs provide preprocessors directives that tell the compiler to preprocess the source code before compiling. All of these preprocessor directives begin with a ‘#’ (hash) symbol. The ‘#’ symbol indicates that, whatever statement starts with #, is going to the preprocessor program, and the preprocessor program will execute this statement. Examples of some preprocessor directives are: **#include, #define, #ifndef etc.** Remember that the # symbol only provides a path that will go to the preprocessor, and a command such as include is processed by the preprocessor program. For example, include will include extra code in your program. We can place these preprocessor directives anywhere in our program. 

**There are 4 Main Types of Preprocessor Directives:**  

1. Macros
2. File Inclusion
3. Conditional Compilation
4. Other directives

# Macros

A **macro** is a piece of code in a program that is replaced by the value of the macro. Macro is defined by #define directive. Whenever a macro name is encountered by the compiler, it replaces the name with the definition of the macro. Macro definitions need not be terminated by a semi-colon(;).
Below are the programs to illustrate the use of macros in C/C++:

```C
// C program to illustrate macros
#include <stdio.h>

// Macro definition
#define LIMIT 5

// Driver Code
int main()
{
	// Print the value of macro defined
	printf("The value of LIMIT"
		" is %d",
		LIMIT);

	return 0;
}
```

```C
// C program to illustrate macros
#include <stdio.h>

// Macro definition
#define AREA(l, b) (l * b)

// Driver Code
int main()
{
	// Given lengths l1 and l2
	int l1 = 10, l2 = 5, area;

	// Find the area using macros
	area = AREA(l1, l2);

	// Print the area
	printf("Area of rectangle"
		" is: %d",
		area);

	return 0;
}
```

## Types Of Macros

1. **Object-like Macros:** An object-like macro is a simple identifier that will be replaced by a code fragment. It is called object-like because it looks like an object in code that uses it. It is popularly used to replace a symbolic name with numerical/variable represented as constant.
Below is the illustration of a simple macro:

```C
// C program to illustrate macros
#include <stdio.h>

// Macro definition
#define DATE 31

// Driver Code
int main()
{
	// Print the message
	printf("Lockdown will be extended"
		" upto %d-MAY-2020",
		DATE);

	return 0;
}
```

2. **Chain Macros:** Macros inside macros are termed as chain macros. In chain macros first of all parent macro is expanded then the child macro is expanded. 
Below is the illustration of a Chain Macro:

```C
// C program to illustrate macros
#include <stdio.h>

// Macro definition
#define INSTAGRAM FOLLOWERS
#define FOLLOWERS 138

// Driver Code
int main()
{
	// Print the message
	printf("Geeks for Geeks have %dK"
		" followers on Instagram",
		INSTAGRAM);

	return 0;
}
```

**Explanation:** 
INSTAGRAM is expanded first to produce FOLLOWERS. Then the expanded macro is expanded to produce the outcome as 138. This is called the chaining of macros.

3. **Multi-line Macros:** An object-like macro could have a multi-line. So to create a multi-line macro you have to use backslash-newline. 
Below is the illustration of multiline macros:

```C
// C program to illustrate macros
#include <stdio.h>

// Multi-line Macro definition
#define ELE 1, \
			2, \
			3

// Driver Code
int main()
{

	// Array arr[] with elements
	// defined in macros
	int arr[] = { ELE };

	// Print elements
	printf("Elements of Array are:\n");

	for (int i = 0; i < 3; i++) {
		printf("%d ", arr[i]);
	}
	return 0;
}
```

4. **Function-like Macro:** These macros are the same as a function call. It replaces the entire code instead of a function name. Pair of parentheses immediately after the macro name is necessary. If we put a space between the macro name and the parentheses in the macro definition then the macro will not work. 
    * A function-like macro is only lengthened if and only if its name appears with a pair of parentheses after it. If we don’t do this, the function pointer will get the address of the real function and lead to a syntax error.
Below is the illustration of function-like macros:

```C
// C program to illustrate macros
#include <stdio.h>

// Function-like Macro definition
#define min(a, b) (((a) < (b)) ? (a) : (b))

// Driver Code
int main()
{

	// Given two number a and b
	int a = 18;
	int b = 76;

	printf("Minimum value between"
		" %d and %d is %d\n",
		a, b, min(a, b));

	return 0;
}
```

Here is another example that will give you a better understanding of Macros:
Problem: We need to find the area of a circle by defining **AREA(r)** Macros. 

```C
#include <iostream>
using namespace std;
#define PI 3.1416
#define AREA(r) (PI*(r)*(r))

int main() {
	
	float r = 7; // radius of circle
	
	cout<<"Area of Circle with radius " << r <<": "<< AREA(r);

	return 0;
}

// This code is contributed by balbiriitbombay3602
```

## File Inclusion

This type of preprocessor directive tells the compiler to include a file in the source code program. There are two types of files that can be included by the user in the program: 

**Header File or Standard files:** These files contain definitions of pre-defined functions like **printf(), scanf(), etc.** These files must be included for working with these functions. Different functions are declared in different header files. For example, standard I/O functions are in ‘iostream’ file whereas functions that perform string operations are in the ‘string’ file.

```C
#include< file_name >
```

where file_name is the name of the file to be included. The ‘<‘ and ‘>’ brackets tell the compiler to look for the file in the standard directory. 

**user-defined files:** When a program becomes very large, it is good practice to divide it into smaller files and include them whenever needed. These types of files are user-defined files. These files can be included as:

```C
#include"filename"
```

## Conditional Compilation

Conditional Compilation directives are a type of directive that helps to compile a specific portion of the program or to skip the compilation of some specific part of the program based on some conditions. This can be done with the help of two preprocessing commands **'ifdef' and 'endif'.**

```C
#ifdef macro_name
    statement1;
    statement2;
    statement3;
    .
    .
    .
    statementN;
#endif
```

If the macro with the name *'macroname'* is defined then the block of statements will execute normally but if it is not defined, the compiler will simply skip this block of statements. 


## Other Directives 

Apart from the above directives, there are two more directives that are not commonly used. These are: 

**#undef Directive:** The #undef directive is used to undefine an existing macro. This directive works as:

```C
#undef LIMIT
```

Using this statement will undefine the existing macro LIMIT. After this statement, every “#ifdef LIMIT” statement will evaluate as false. 

**#pragma Directive:** This directive is a special purpose directive and is used to turn on or off some features. This type of directives are compiler-specific, i.e., they vary from compiler to compiler. Some of the #pragma directives are discussed below: 
	* **#pragma startup** and **#pragma exit:** These directives help us to specify the functions that are needed to run before program startup( before the control passes to main()) and just before program exit (just before the control returns from main()). 

***Note: Below program will not work with GCC compilers.***

```C
#include <bits/stdc++.h>
using namespace std;
	
void func1();
void func2();

#pragma startup func1
#pragma exit func2

void func1()
{
	cout << "Inside func1()\n";
}

void func2()
{
	cout << "Inside func2()\n";
}

int main()
{
	void func1();
	void func2();
	cout << "Inside main()\n";

	return 0;
}

// This code is contributed by shivanisinghss2110
```

Output: 

```
Inside func1()
Inside main()
Inside func2()
```

The above code will produce the output as given below when run on GCC compilers: 

```
Inside main()
```

This happens because GCC does not support #pragma startup or exit. ***However, you can use the below code for a similar output on GCC compilers.***

```C
#include <iostream>
using namespace std;

void func1();
void func2();

void __attribute__((constructor)) func1();
void __attribute__((destructor)) func2();

void func1()
{
	printf("Inside func1()\n");
}

void func2()
{
	printf("Inside func2()\n");
}

// Driver code
int main()
{
	printf("Inside main()\n");

	return 0;
}

// This code is contributed by Shivani
```

**#pragma warn Directive:** This directive is used to hide the warning message which is displayed during compilation. We can hide the warnings as shown below: 

* **#pragma warn -rvl:** This directive hides those warning which is raised when a function that is supposed to return a value does not return a value.
* **#pragma warn -par:** This directive hides those warning which is raised when a function does not use the parameters passed to it.
* **#pragma warn -rch:** This directive hides those warning which is raised when a code is unreachable. For example, any code written after the return statement in a function is unreachable.

### References:

[TutorialsPoint](https://www.tutorialspoint.com/cprogramming/c_constants.htm)

[Competitive Programmer's Handbook](https://cses.fi/book/book.pdf)

[GeeksForGeeks Macros](https://www.geeksforgeeks.org/macros-and-its-types-in-c-cpp/)

[GeeksForGeeks Preprocessors](https://www.geeksforgeeks.org/cc-preprocessors/)
