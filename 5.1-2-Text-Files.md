# Text files

The `fstream` library allows us to work with files. [1][1]

To use the fstream library, include both the standard `<iostream>` AND the `<fstream>` header file: [1][1]

```C
#include <iostream>
#include <fstream> 
```

There are three classes included in the `fstream` library, which are used to create, write or read files:

| Class |	Description |
| --- | --- |
|ofstream |	Creates and writes to files |
|ifstream |	Reads from files |
|fstream |	A combination of ofstream and ifstream:| creates, reads, and writes to files|

## Create and Write To a File

To create a file, use either the `ofstream` or `fstream` class, and specify the name of the file.

To write to the file, use the insertion operator (`<<`).

```C
#include <iostream>
#include <fstream>
using namespace std;

int main() {
  // Create and open a text file
  ofstream MyFile("filename.txt");

  // Write to the file
  MyFile << "Files can be tricky, but it is fun enough!";

  // Close the file
  MyFile.close();
} 
```

> # Why do we close the file?
>
> It is considered good practice, and it can clean up unnecessary memory space.
>

## Read a File

To read from a file, use either the `ifstream` or `fstream` class, and the name of the file.

Note that we also use a `while` loop together with the `getline()` function (which belongs to the `ifstream` class) to read the file line by line, and to print the content of the file:

```C
// Create a text string, which is used to output the text file
string myText;

// Read from the text file
ifstream MyReadFile("filename.txt");

// Use a while loop together with the getline() function to read the file line by line
while (getline (MyReadFile, myText)) {
  // Output the text from the file
  cout << myText;
}

// Close the file
MyReadFile.close(); 
```


## Alternative methods

## C++ method

We can declare `fin` and `fout` as replacements for `ifstream` and `ofstream`.

```C++
#include <fstream>
using namespace std;
ifstream fin("MYFILE.in"); // input file
ofstream fout("MYFILE.out"); // output file

// you can use the same file if needed, but problems often require separate files

int main() {
    // use fin and fout instead of cin and cout
    int a;
    fin>>a;
    fout<<a;
    return 0;
}
```

## C method

When working with files, you need to declare a pointer of type file. This declaration is needed for communication between the file and the program. [2][2]

```C
FILE *fptr;
```

## Opening a file - for creation and edit

Opening a file is performed using the `fopen()` function defined in the `stdio.h` header file.

The syntax for opening a file in standard I/O is:

```C
ptr = fopen("fileopen","mode");
```

For example,

```C
fopen("/home/mihai/Documents/text.txt","w");

fopen("/home/mihai/Documents/dump.bin","rb");
```

> **Note:** If you are unfamiliar with this directory structure, don't worry, it's just the 'default Linux file structure'

* Let's suppose the file `text.txt` doesn't exist in the location `/home/mihai/Documents/`. The first function creates a new file named newprogram.txt and opens it for writing as per the mode **'w'**. The writing mode allows you to create and edit (overwrite) the contents of the file.

* Now let's suppose the second binary file `dump.bin` exists in the location `/home/mihai/Documents/`. The second function opens the existing file for reading in binary mode **'rb'**.
The reading mode only allows you to read the file, you cannot write into the file.

### Opening Modes in Standard I/O 
| Mode	| Meaning of Mode | During Inexistence of file |
| --- | --- | --- |		
| r | Open for reading. | If the file does not exist, fopen() returns NULL. |
| rb |	Open for reading in binary mode. | If the file does not exist, fopen() returns NULL. |
| w | Open for writing. | If the file exists, its contents are overwritten. If the file does not exist, it will be created. |
| wb | Open for writing in binary mode. | If the file exists, its contents are overwritten. If the file does not exist, it will be created. |	
| a | Open for append. | Data is added to the end of the file. If the file does not exist, it will be created. |		
| ab | Open for append in binary mode. | Data is added to the end of the file.If the file does not exist, it will be created. |
| r+ | Open for both reading and writing. | If the file does not exist, fopen() returns NULL. |
| rb+ | Open for both reading and writing in binary mode. | If the file does not exist, fopen() returns NULL. |
| w+ | Open for both reading and writing. | If the file exists, its contents are overwritten. If the file does not exist, it will be created. |
| wb+ | Open for both reading and writing in binary mode. | If the file exists, its contents are overwritten. If the file does not exist, it will be created. | 
| a+ | Open for both reading and appending. | If the file does not exist, it will be created. |
| ab+ | Open for both reading and appending in binary mode. | If the file does not exist, it will be created. |
		
## Closing a File

The file (both text and binary) should be closed after reading/writing.

Closing a file is performed using the `fclose()` function.

```C
fclose(fptr);
```

Here, `fptr` is a file pointer associated with the file to be closed.

# Reading and writing to a text file

For reading and writing to a text file, we use the functions `fprintf()` and `fscanf()`.

They are just the file versions of `printf()` and `scanf()`. The only difference is that `fprintf()` and `fscanf()` expects a pointer to the structure FILE.

### Example 1: Write to a text file

```C
#include <stdio.h>
#include <stdlib.h>

int main()
{
   int num;
   FILE *fptr;

   // use appropriate location if you are using MacOS or Linux
   fptr = fopen("C:\\program.txt","w");

   if(fptr == NULL)
   {
      printf("Error!");   
      exit(1);             
   }

   printf("Enter num: ");
   scanf("%d",&num);

   fprintf(fptr,"%d",num);
   fclose(fptr);

   return 0;
}
```

This program takes a number from the user and stores in the file program.txt.

After you compile and run this program, you can see a text file program.txt created in C drive of your computer. When you open the file, you can see the integer you entered.

### Example 2: Read from a text file

```C
#include <stdio.h>
#include <stdlib.h>

int main()
{
   int num;
   FILE *fptr;

   if ((fptr = fopen("C:\\program.txt","r")) == NULL){
       printf("Error! opening file");

       // Program exits if the file pointer returns NULL.
       exit(1);
   }

   fscanf(fptr,"%d", &num);

   printf("Value of n=%d", num);
   fclose(fptr); 
  
   return 0;
}
```
This program reads the integer present in the program.txt file and prints it onto the screen.

If you successfully created the file from Example 1, running this program will get you the integer you entered.

Other functions like `fgetchar()`, `fputc()` etc. can be used in a similar way.

## Reading and writing to a binary file

Functions `fread()` and `fwrite()` are used for reading from and writing to a file on the disk respectively in case of binary files.

### Writing to a binary file

To write into a binary file, you need to use the fwrite() function. The functions take four arguments:

1. address of data to be written in the disk
2. size of data to be written in the disk
3. number of such type of data
    pointer to the file where you want to write.

```C
fwrite(addressData, sizeData, numbersData, pointerToFile);
```

### Example 3: Write to a binary file using fwrite()

```C
#include <stdio.h>
#include <stdlib.h>

struct threeNum
{
   int n1, n2, n3;
};

int main()
{
   int n;
   struct threeNum num;
   FILE *fptr;

   if ((fptr = fopen("C:\\program.bin","wb")) == NULL){
       printf("Error! opening file");

       // Program exits if the file pointer returns NULL.
       exit(1);
   }

   for(n = 1; n < 5; ++n)
   {
      num.n1 = n;
      num.n2 = 5*n;
      num.n3 = 5*n + 1;
      fwrite(&num, sizeof(struct threeNum), 1, fptr); 
   }
   fclose(fptr); 
  
   return 0;
}
```
In this program, we create a new file program.bin in the C drive.

We declare a structure threeNum with three numbers - n1, n2 and n3, and define it in the main function as num.

Now, inside the for loop, we store the value into the file using `fwrite()`.

The first parameter takes the address of num and the second parameter takes the size of the structure threeNum.

Since we're only inserting one instance of num, the third parameter is 1. And, the last parameter *fptr points to the file we're storing the data.

Finally, we close the file.


### Reading from a binary file

Function `fread()` also take 4 arguments similar to the `fwrite()` function as above.

```C
fread(addressData, sizeData, numbersData, pointerToFile);
```

### Example 4: Read from a binary file using fread()

```C
#include <stdlib.h>

struct threeNum
{
   int n1, n2, n3;
};

int main()
{
   int n;
   struct threeNum num;
   FILE *fptr;

   if ((fptr = fopen("C:\\program.bin","rb")) == NULL){
       printf("Error! opening file");

       // Program exits if the file pointer returns NULL.
       exit(1);
   }

   for(n = 1; n < 5; ++n)
   {
      fread(&num, sizeof(struct threeNum), 1, fptr); 
      printf("n1: %d\tn2: %d\tn3: %d\n", num.n1, num.n2, num.n3);
   }
   fclose(fptr); 
  
   return 0;
}
```

In this program, you read the same file program.bin and loop through the records one by one.

In simple terms, you read one threeNum record of threeNum size from the file pointed by *fptr into the structure num.

You'll get the same records you inserted in Example 3.

### Getting data using fseek()

If you have many records inside a file and need to access a record at a specific position, you need to loop through all the records before it to get the record.

This will waste a lot of memory and operation time. An easier way to get to the required data can be achieved using fseek().

As the name suggests, fseek() seeks the cursor to the given record in the file.

### Syntax of fseek()

fseek(FILE * stream, long int offset, int whence);

The first parameter stream is the pointer to the file. The second parameter is the position of the record to be found, and the third parameter specifies the location where the offset starts.

### Different whence in fseek()
| Whence | Meaning |
| --- | --- |		
SEEK_SET | Starts the offset from the beginning of the file.
SEEK_END | Starts the offset from the end of the file.
SEEK_CUR | Starts the offset from the current location of the cursor in the file.

### Example 5: fseek()

```C
#include <stdio.h>
#include <stdlib.h>

struct threeNum
{
   int n1, n2, n3;
};

int main()
{
   int n;
   struct threeNum num;
   FILE *fptr;

   if ((fptr = fopen("C:\\program.bin","rb")) == NULL){
       printf("Error! opening file");

       // Program exits if the file pointer returns NULL.
       exit(1);
   }
   
   // Moves the cursor to the end of the file
   fseek(fptr, -sizeof(struct threeNum), SEEK_END);

   for(n = 1; n < 5; ++n)
   {
      fread(&num, sizeof(struct threeNum), 1, fptr); 
      printf("n1: %d\tn2: %d\tn3: %d\n", num.n1, num.n2, num.n3);
      fseek(fptr, -2*sizeof(struct threeNum), SEEK_CUR);
   }
   fclose(fptr); 
  
   return 0;
}
```

This program will start reading the records from the file program.bin in the reverse order (last to first) and prints it. [2][2]

[1]: https://www.w3schools.com/cpp/cpp_files.asp
[2]: https://www.programiz.com/c-programming/c-file-input-output