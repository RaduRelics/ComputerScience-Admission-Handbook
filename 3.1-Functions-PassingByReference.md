# Functions, Passing by value/reference

A function is a set of statements that take inputs, do some specific computation and produces output.

The idea is to put some commonly or repeatedly done task together and make a function so that instead of writing the same code again and again for different inputs, we can call the function.

The general form of a function is:

```C
return_type function_name([ arg1_type arg1_name, ... ]) { code }
```

Below is a simple C/C++ program to demonstrate functions.

```C
#include <stdio.h>

// An example function that takes two parameters 'x' and 'y'
// as input and returns max of two input numbers
int max(int x, int y)
{
	if (x > y)
	return x;
	else
	return y;
}

// main function that doesn't receive any parameter and
// returns integer.
int main(void)
{
	int a = 10, b = 20;

	// Calling above function to find max of 'a' and 'b'
	int m = max(a, b);

	printf("m is %d", m);
	return 0;
}
```

### Why do we need functions?

* Functions help us in reducing code redundancy. If functionality is performed at multiple places in software, then rather than writing the same code, again and again, we create a function and call it everywhere. This also helps in maintenance as we have to change at one place if we make future changes to the functionality.
* Functions make code modular. Consider a big file having many lines of code. It becomes really simple to read and use the code if the code is divided into functions.
* Functions provide abstraction. For example, we can use library functions without worrying about their internal working.

## Function Declaration

A function declaration tells the compiler about the number of parameters function takes, data-types of parameters, and return type of function. Putting parameter names in function declaration is optional in the function declaration, but it is necessary to put them in the definition. Below are an example of function declarations. (parameter names are not there in below declarations)

![](/img/Function-Prototype-in-c.png)


```C
// A function that takes two integers as parameters
// and returns an integer
int max(int, int);

// A function that takes an int pointer and an int variable as parameters
// and returns a pointer of type int
int *swap(int*,int);

// A function that takes a charas parameters
// and returns an reference variable
char *call(char b);

// A function that takes a char and an int as parameters
// and returns an integer
int fun(char, int);
```

It is always recommended to declare a function before it is used. (See [this](https://www.geeksforgeeks.org/what-is-the-purpose-of-a-function-prototype/), [this](https://www.geeksforgeeks.org/g-fact-95/) and [this](https://www.geeksforgeeks.org/importance-of-function-prototype-in-c/) for details)

In C, we can do both declaration and definition at the same place, like done in the above example program.

C also allows to declare and define functions separately, this is especially needed in the case of library functions. The library functions are declared in header files and defined in library files.

## Parameter Passing to functions

The parameters passed to function are called **actual parameters**. For example, in the above program 10 and 20 are actual parameters.
The parameters received by function are called **formal parameters**. For example, in the above program x and y are formal parameters.

There are two popular ways to pass parameters:

* **Pass by Value:** In this parameter passing method, values of actual parameters are copied to function’s formal parameters and the two types of parameters are stored in different memory locations. So any changes made inside functions are not reflected in actual parameters of caller.
* **Pass by Reference:** Both actual and formal parameters refer to same locations, so any changes made inside the function are actually reflected in actual parameters of caller.

Parameters are always passed by value in C. For example. in the code below, the value of x is not modified using the function fun().

```C
#include <stdio.h>
void fun(int x)
{
x = 30;
}

int main(void)
{
	int x = 20;
	fun(x);
	printf("x = %d", x);
	return 0;
}
```

***However***, in C, we can use **pointers** to get the effect of pass-by reference. For example, consider the program below. The function fun() expects a pointer ptr to an integer (or an address of an integer). It modifies the value at the address ptr. The dereference operator * is used to access the value at an address. 

In the statement ‘*ptr = 30’, value at address ptr is changed to 30. The address operator & is used to get the address of a variable of any data type. In the function call statement ‘fun(&x)’, the address of x is passed so that x can be modified using its address.

```C
#include <stdio.h>
void fun(int *ptr)
{
	*ptr = 30;
}

int main()
{
int x = 20;
fun(&x);
printf("x = %d", x);

return 0;
}
```

In C++ we could rewrite it as:

```C++
#include <iostream>

void fun(int &ptr)
{
    ptr = 30;
}

int main()
{
    int x = 20;
    fun(&x);
    cout<<"x = "<<x;
    
    return 0;
}
```

## Important points about functions in C:

1) Every C program has a function called main() that is called by the operating system when a user runs the program.

2) Every function has a return type. If a function doesn’t return any value, then void is used as a return type. Moreover, if the return type of the function is void, we still can use return statement in the body of function definition by not specifying any constant, variable, etc. with it, by only mentioning the 'return;' statement which would symbolize the termination of the function as shown below:

```C
void function name(int a)
{
....... //Function Body
return; //Function execution would get terminated
}			
```

>**Note for students:** Some teachers might disagree with this statement as the use of return in void functions is often considered useless 

3) In C, functions can return any type except arrays and functions. We can get around this limitation by returning pointer to array or pointer to function.
4) Empty parameter list in C means that the parameter list is not specified and function can be called with any parameters. In C, it is not a good idea to declare a function like fun(). To declare a function that can only be called without any parameter, we should use **"void fun(void)"**.
***As a side note, in C++, an empty list means a function can only be called without any parameter. In C++, both void fun() and void fun(void) are same.***
5) If in a C program, a function is called before its declaration then the C compiler automatically assumes the declaration of that function in the following way:
```C
int function name();
```
And in that case, if the return type of that function is different than INT, the compiler would show an error.

## Main Function:

The main function is a special function. Every C++ program must contain a function named main. It serves as the entry point for the program. The computer will start running the code from the beginning of the main function.

## Types of main Functions:

1) The first type is – main function without parameters:

```C++
// Without Parameters
int main()
{
...
return 0;
}
```

2) Second type is main function with parameters:

```C++
// With Parameters
int main(int argc, char * const argv[])
{
...
return 0;
}
```

The reason for having the parameter option for the main function is to **allow input from the command line.**

**When you use the main function with parameters, it saves every group of characters (separated by a space) after the program name as elements in an array named argv.**

For instance if we were to provide a help function to our CLI (command line interface) app, we could call it like this:

```BASH
./main.o --help
```

This syntax is often seen in Unix-like operating systems.

Since the main function has the return type of int, the programmer must always have a return statement in the code. The number that is returned is used to inform the calling program what the result of the program’s execution was. Returning 0 signals that there were no problems.

## Calling a Function

Declared functions are **not executed immediately.** They are "saved for later use", and will be executed later, when they are called.

To call a function, write the function's name followed by two parentheses () and a semicolon ;

In the following example, myFunction() is used to print a text (the action), when it is called:

```C++
// Create a function
void myFunction() {
  cout << "I just got executed!";
}

int main() {
  myFunction(); // call the function
  return 0;
}

// Outputs "I just got executed!"
```

A function can be called multiple times:

```C++
void myFunction() {
  cout << "I just got executed!\n";
}

int main() {
  myFunction();
  myFunction();
  myFunction();
  return 0;
}

// I just got executed!
// I just got executed!
// I just got executed!
```

## Function Declaration and Definition

A C++ function consist of two parts:

* **Declaration:** the return type, the name of the function, and parameters (if any)
* **Definition:** the body of the function (code to be executed)

```C
void myFunction() { // declaration
  // the body of the function (definition)
}
```

> **Note:** If a user-defined function, such as myFunction() is declared after the main() function, an error will occur:

However, it is possible to separate the declaration and the definition of the function - for code optimization.

You will often see C++ programs that have function declaration above main(), and function definition below main(). This will make the code better organized and easier to read:

```C++
// Function declaration
void myFunction();

// The main method
int main() {
  myFunction();  // call the function
  return 0;
}

// Function definition
void myFunction() {
  cout << "I just got executed!";
}
```

## Function Overloading

With **function overloading**, multiple functions can have the same name with different parameters:

```C
int myFunction(int x)
float myFunction(float x)
double myFunction(double x, double y)
```

Consider the following example, which have two functions that add numbers of different type:

```C
int plusFuncInt(int x, int y) {
  return x + y;
}

double plusFuncDouble(double x, double y) {
  return x + y;
}

int main() {
  int myNum1 = plusFuncInt(8, 5);
  double myNum2 = plusFuncDouble(4.3, 6.26);
  cout << "Int: " << myNum1 << "\n";
  cout << "Double: " << myNum2;
  return 0;
}
```

Instead of defining two functions that should do the same thing, it is better to overload one.

In the example below, we overload the plusFunc function to work for both int and double:

```C
int plusFunc(int x, int y) {
  return x + y;
}

double plusFunc(double x, double y) {
  return x + y;
}

int main() {
  int myNum1 = plusFunc(8, 5);
  double myNum2 = plusFunc(4.3, 6.26);
  cout << "Int: " << myNum1 << "\n";
  cout << "Double: " << myNum2;
  return 0;
}
```

> **Note:** Multiple functions can have the same name as long as the number and/or type of parameters are different.

# Recursion

Recursion is the technique of making a function call itself. This technique provides a way to break complicated problems down into simple problems which are easier to solve.

Recursion may be a bit difficult to understand. The best way to figure out how it works is to experiment with it.

More about recursion in [later chapters]().


# References

A reference variable is a "reference" to an existing variable, and it is created with the & operator:

```C
string food = "Pizza";  // food variable
string &meal = food;    // reference to food
```

Now, we can use either the variable name food or the reference name meal to refer to the food variable:

```C
string food = "Pizza";
string &meal = food;

cout << food << "\n";  // Outputs Pizza
cout << meal << "\n";  // Outputs Pizza
```

## Memory Address

In the previous example, the & operator was used to create a reference variable. But it can also be used to get the memory address of a variable; which is the location of where the variable is stored on the computer.

When a variable is created in C++, a memory address is assigned to the variable. And when we assign a value to the variable, it is stored in this memory address.

To access it, use the & operator, and the result will represent where the variable is stored:

```C
string food = "Pizza";

cout << &food; // Outputs 0x6dfed4
```

> **Note:** The memory address is in hexadecimal form (0x..). Note that you may not get the same result in your program.


*And why is it useful to know the memory address?*

References and Pointers (which you will learn about later) are important in C++, because they give you the ability to manipulate the data in the computer's memory - which can reduce the code and improve the performance.

These two features are one of the things that make C++ stand out from other programming languages, like Python and Java.


# Pointers

You learned previously that we can get the memory address of a variable by using the & operator and that we can pass values by reference to a function.

A **pointer** however, is a variable that **stores the memory address as its value.**

A pointer variable points to a data type (like int or string) of the same type, and is created with the * operator. The address of the variable you're working with is assigned to the pointer:

```C++
string food = "Pizza";  // A food variable of type string
string* ptr = &food;    // A pointer variable, with the name ptr, that stores the address of food

// Output the value of food (Pizza)
cout << food << "\n";

// Output the memory address of food (0x6dfed4)
cout << &food << "\n";

// Output the memory address of food with the pointer (0x6dfed4)
cout << ptr << "\n";
```

>**Example explained**
>
>Create a pointer variable with the name ptr, that points to a string variable, by using the asterisk sign * (string* ptr). Note that the type of the pointer has to match the type of the variable you're working with.
>
>Use the & operator to store the memory address of the variable called food, and assign it to the pointer.
>
>Now, ptr holds the value of food's memory address.

>**Tip:** There are three ways to declare pointer variables, but the first way is preferred:
```C
string* mystring; // Preferred
string *mystring;
string * mystring;
```

## Get Memory Address and Value

In the previous example, we used the pointer variable to get the memory address of a variable (used together with the & reference operator). However, you can also use the pointer to get the value of the variable, by using the * operator (the dereference operator):

```C
string food = "Pizza";  // Variable declaration
string* ptr = &food;    // Pointer declaration

// Reference: Output the memory address of food with the pointer (0x6dfed4)
cout << ptr << "\n";

// Dereference: Output the value of food with the pointer (Pizza)
cout << *ptr << "\n";
```

>Note that the * sign can be confusing here, as it does two different things in our code:
> * When used in declaration (string* ptr), it creates a pointer variable.
> * When not used in declaration, it act as a dereference operator.

## Modify the Pointer Value

You can also change the pointer's value. But note that this will also change the value of the original variable:

```C
string food = "Pizza";
string* ptr = &food;

// Output the value of food (Pizza)
cout << food << "\n";

// Output the memory address of food (0x6dfed4)
cout << &food << "\n";

// Access the memory address of food and output its value (Pizza)
cout << *ptr << "\n";

// Change the value of the pointer
*ptr = "Hamburger";

// Output the new value of the pointer (Hamburger)
cout << *ptr << "\n";

// Output the new value of the food variable (Hamburger)
cout << food << "\n";
```

### References:

[GeeksForGeeks Functions](https://www.geeksforgeeks.org/functions-in-c/)

[W3Schools Functions](https://www.w3schools.com/cpp/cpp_functions.asp)

[W3Schools References](https://www.w3schools.com/cpp/cpp_references.asp)

[W3Schools Pointers](https://www.w3schools.com/cpp/cpp_pointers.asp)